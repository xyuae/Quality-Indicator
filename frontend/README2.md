## Seperating frontend and backend
前后端分离的架构模式，一般指的是不采用后端模板引擎来根据数据库数据动态渲染前端html，同时将路由交由前端的前后端合作方式。
也就是前端需要控制路由来管理自己的静态资源与数据获取。
其他的配合react完成前后端分离的主流路由库一般就是react-router
后端专注做业务逻辑，不在后端做页面渲染的事情，只向前端提供数据接口。将前后端完全分离，页面上的所有数据都通过ajax向后端取，页面渲染的事情完全由前端来做。

前端使用React框架以及React-Router路由框架。搭建完成前端的开发环境后用AJAX完成与后端的交互。后端使用Django框架，数据以JSON形式传递。

一个大型互联网网站，是一群web项目的集合。如果不在前端进行整合，这么多web项目前端开发一定存在大量重复劳动，并且在运维的时候也存在难以统一管理的问题。
前后端分离的目的和作用
做web开发也可以说是B/S架构开发，B端与S端从技术体系角度而言异构性很大，换而言之就是B端使用的技术和S端使用的技术不适用于同一个体系，这样的结果导致实际开发中，很难做到专业分工，如果项目开发过程中管控不到位，这样的问题可能会影响到整个项目的开发质量，因此前后端分离的目的之一就是要做到专业化分工，提高项目的质量和开发效率。
随着技术的发展，当下的web开发形势已经和以前有了很大的不同，早期的web项目是一个封闭项目，用户从阅览器看到的页面知道后台数据库都是在一个项目里继承的，而现在web系统的规模越来越大，中大型的web系统是一个开放式的系统，开放型的系统用户在阅览器发起的请求可能会转发到外部的系统里进行处理，或者是本地的系统和外部系统一起完成请求的处理，此外有的请求可能不会直接请求数据库，而是请求缓存服务器，这些变化几乎都是发生在web系统的服务端，前后端耦合度很高的web系统服务端的复杂度提升必然带来了web前端复杂度的提升。因此web前端从系统架构的角度也需要更加专业的管控，管控的作用之一就是前后端进行分离，降低前端对服务端的依耐性。
富客户端应用的普及导致web前端技术开发更加专业化，web前端工程师成为一个独立的技术岗位，web前端开发技术的难度也越来越高，前后端的分离就是为web前端开发营造一个良好的开发环境，不要让前端工程师被一些不可控的外在因素影响（前后端的耦合性），最后导致前端不能专心作出更加好的作品。所以，前后端分离是让前后端更加专业化，在技术和管理上将前端角色更加明确，更深入地挖掘前端开发地价值。
在实际开发里最常发生地事情是控制层越过服务层直接处理下面地资源。

前后段耦合地问题主要发生在控制层，控制层是前端和服务端交互的边界
但是在开发过程中控制层和服务层常常混淆不清，这就是前后端耦合度高的重要原因。
因此需要前后端解耦，就是要划请控制层的边界，控制层到底该属于
前端还是服务端，在MVC模式里控制层作用是调度，控制层不是写业务逻辑的地方，因此将大量业务逻辑写道控制层实际是违背了MVC模式的思想，同时控制层是前端和服务端通讯的桥梁，其实控制层是参入了前端的工作任务，既然控制层要剥离业务操作同时控制层也要参入前端应用的开发，那么将控制层归为前端的一部分是完全合情合理合规的。
把控制层剥离了业务逻辑处理。
不管服务端还是前端宏观流程都是输入数据，数据处理，输出数据，但是服务端要把心思花在数据处理上，前端要更多关心的是输入输出数据时候的用户体验操作，服务端开发最大的问题就是违背MVC原则，代码编写的随意性，而前端不管出于安全还是性能考虑，最好是尽量少牵涉业务。前端和后端通讯层的独立，会将前后端进行真正的解耦。


## web application
我们不相忘接触到TCP连接、http原始请求和响应那个格式，所以需要一个统一的接口，让我们专心用python编写web业务。这个接口就是wsgi: web server gateway interface
### MVC Design Pattern
MVC 就是把web应用分为模型（M），控制器（C），试图（V）三层；他们之间以一种插件似的，松耦合的方式连接在一起。
模型负责业务对象与数据库的对象（ORM），视图负责域用户的交互，控制器（C）接受用户的输入调用模型和视图完成用户的请求。
Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同， Django的MTV分别代表：
Model（模型）：负责业务对象与数据库的对象（ORM）
Template（模板）：负责如何把页面展示给用户
View（视图）：负责业务逻辑，斌在适当的时候调用Model和Template
此外，Django还有一个url分发器，他的作用是将一个个url的页面请求分发给不同的view处理，view再调用相应的Model和Template.

## Flask， Django， Pyramid的比较
他们是微框架和商业级web服务的典范
Flask是一个微框架，主要面向需求简单的小应用。Pyramid和Django都是面向大的应用，但是在扩展性和灵活性上走了不同的路。Pyramid关注灵活性，让开发者选择合适的工具来开发项目。这意味着开发者可以选择数据库，URL结构，模板风格等。Django的目标是提供web应用开发的一站式解决方案，所以相应的模块也比较多。
Django的一站式解决的思路能让开发者不用再开发之前就花大量时间在选择应用的基础设置上。
尽管Flask的历史较短，但它能够从以前的框架学到一些东西并且将他的目标设定在了小型项目上。他在一些仅有一两个功能的小型项目上得到了大量应用。比如httpbin这样的项目，简单但非常强大，是一个帮助debug和测试http的库。

Pyramid
跟Flask类似，Pyramid支持很多模板语言（包括Jinja2和Mako)，但他有一个默认的模板。Pyramid使用Chameleon,一个ZPT（the Zope Page Template)语言的实现。我们来看一个例子，把用户的名字添加到网站顶端。相应的Python代码有点类似但更加明确，不用调用render_template函数。
'''
@view_config(render='templates/home.pt')
def my_view(request):
	# do stuff ...
	return {'user': user}
'''
## 框架实战
做一个社交网络，可以告诉整个因特网你晚饭吃了什么。这个应用回事一个简单的接口，能让用户po出他们午饭吃了什么，还可以看到别人吃了什么。
flask
首先，我们需要初始化我们的应用和引入orm.
'''
from flask import Flask

'''
