## Node.js and Django
## Node.js
node.js是基于异步事件驱动的高性能非阻塞IO框架。

non-blocking I/O model， 得从最初得服务器网络模型说起。
最初得服务器都是单进程得阻塞I/O。 所有得请求都在同行一个京城里连续处理，如果当前请求耗费了较长得CPU时间，
那么其他后续所有请求都要等待这个请求处理借宿后才能处理，而在处理期间这个京城也会被挂起。所谓是一卡全部卡。

在这之后发展出的是多进程多县城得网络模型。首先是简单得多进程模型：对于每一个连接都分配
一个进程。这种做法简单粗暴得解决了一个请求阻塞导致全部请求都阻塞得问题，在请求量少高但是不那么高得
场景下足够了。但是一旦请求量多，就会暴露出两个缺点
1. 一个进程所需的系统资源是不容忽视得，对于高并发情况下系统资源极易耗尽。
2. 能够处理得进程数取决于cpu核数，进程越多意味着更频繁得进程调度，也就意味着更多得时间被花在进程切换上，
导致整个系统性能下降。
多线程模型只是把压力阈值提高了一些，仍然有部分系统资源， cpu时间浪费在非处理请求上。

任何一步因为任何原因阻塞了都会导致这个处理单元得阻塞，并被挂起。假如我们在一个请求得处理过程中需要
查询数据库，或是依赖外部服务，而这些操作又有很大得延迟，那么在这段时间内处理单元就会被挂起，但由于这个
请求没有处理完，资源就不能拿出来处理其他得请求。所以哪怕服务负载特别高，资源得利用率也不高。所以就催生
除了非阻塞ＩO模型。

非阻塞IO模型在请求量很多得时候，对于每一个用户而言都有很好的体验。
所谓时间驱动，通俗来讲就是发生了什么事，我们才做响应的处理。这里的事件可以是一个
用户操作，可以是一次内容变化，也可以是一次网络请求，甚至可以是一次系统异常。
凡是我们关心的，都可以成为事件，然后我们再做处理。

Asynchronous communication的意思是说，当一个调用到来时，并不等到有结果了再返回，
而是直接返回，有结果了再通知调用方。

同步异步关心的是消息通讯机制，阻塞非阻塞惯性的是服务器等待调用结果时的状态。

##
Socket.io
这是一个用来构建实时web应用的JavaScript库，对于阅览器的客户端核后台服务器端有两套
接口相似的库，于node.js相同，他也是事件驱动的。
多数情况下socket.io是基于websocket协议的，但是对于不支持的阅览器他也能够自动会退到flash或是长轮询。

socket.io的好处就在于自动选择合适的协议，简单易上手的api.可以说Node.js的热度有相当一部分
是由socket.io撑起来的。

后文回答出一套node.js + socket.io + Django + redis 的原型。

Dango和node.js几乎是两种风格的网络框架，所以我们需要一个通信手段。
而系统间通信不外乎就是靠网络请求，或是另一个可以用作通信的系统。
对于Node.js和django之间交互的话，有三种手段可选：
1. http request
2. Redis publish/subscribe
3. RPC
